## 2 项目代码

所有实现代码位于 `skiplist.h` 头文件中，CPP 文件中 include 它就可以使用。内部关键在于定义了 `SkipList` 结构，以及 `Node` 结构。

### 2.1 头文件



```c++
#include <iostream> 
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <mutex>
#include <fstream>
```

------

### 2.2 基本定义



```c++
std::mutex mtx, mtx1;  
std::string delimiter = ":";
```

**说明** :sun_with_face:

:small_blue_diamond: 宏定义数据落盘位置，以及加载数据位置；

:small_orange_diamond: 定义互斥量锁，用于写操作中的临界区；

:small_blue_diamond: 定义分隔符，用于加载数据是识别 **Key** 和 **Value** 。

------

### 2.3 Node

#### 2.3.1 Node 定义

`Node` 结构是 `SkipList` 实现的基础。其定义如下：



```c++
template<typename K, typename V> 
class Node {
// ~ Node 节点定义
public:
    // 构造函数
    Node() {}            
    Node(K k, V v, int); 
    // 析构函数
    ~Node();   
    // 键值对操作相关的成员函数
    K get_key() const;   // 取 Key
    V get_value() const; // 取 value
    void set_value(V);   // 设定 value
    
    // 前向指针数组，内部存前向指针，指向下一个 Node
    Node<K, V> **forward;
    // 节点层数
    int node_level;       
private:
    // 数据成员
    K key; 
    V value;
};
```

**说明** :sun_with_face:

:small_blue_diamond: 私有数据成员 **key** ， **value** ，公有数据成员 **forward** ，**node_level**

:small_orange_diamond: 成员函数：构造函数，析构函数，键值对操作函数

**注意** :raising_hand_man:

**forward** 是一个指针数组，其元素是指向 **Node** 的指针。

------

#### 2.3.2 构造函数和析构函数



```c++
template<typename K, typename V> 
Node<K, V>::Node(const K k, const V v, int level) {
    this->key = k;
    this->value = v;
    this->node_level = level;    
    // forward 大小为 level + 1
    this->forward = new Node<K, V>*[level + 1]; // 分配内存
    memset(this->forward, 0, sizeof(Node<K, V>*)*(level + 1)); // 初始化
};

template<typename K, typename V> 
Node<K, V>::~Node() {
    delete []forward;  // 释放内存
};
```

------

#### 2.3.3 键值对操作函数



```c++
template<typename K, typename V> 
K Node<K, V>::get_key() const {
    return key;
};

template<typename K, typename V> 
V Node<K, V>::get_value() const {
    return value;
};
template<typename K, typename V> 
void Node<K, V>::set_value(V value) {
    this->value = value;
};
```

------

### 2.4 SkipList

#### 2.4.1 SkipList 定义



```c++
template <typename K, typename V> 
class SkipList {
public: 
    // 构造和析构函数，创建 Node 节点函数
    SkipList(int); 
    ~SkipList();   
    Node<K, V>* create_node(K, V, int);
    
    // 增删改查操作函数
    int put_element(K, V);   	     // 增/改
    int delete_element(K);	    	 // 删
    bool search_element(K);			 // 查
    
    void display_list();  // 打印跳表
    void clear(); 		  // 清空跳表
    int size();			  // 返回跳表节点数(不包含头节点)
       
    // 获得随机层高函数
    int get_random_level(); 

private:
    // 数据加载相关函数, 用来区分 key 和 value
    void get_key_value_from_string(const std::string& str, std::string* key, std::string* value);
    bool is_valid_string(const std::string& str);

private:    
    int _max_level;  	   // 跳表层数上限
    int _skip_list_level;  // 当前跳表的最高层 
	int _element_count;    // 跳表中节点数
    Node<K, V> *_header;   // 跳表中头节点指针

    // file operator
    std::ofstream _file_writer;
    std::ifstream _file_reader; 
};
```

**说明** :sun_with_face:

:small_blue_diamond: 私有数据成员 **_max_level, _skip_list_level, _element_count, header, _file_writer, file_reader**

:small_orange_diamond: 成员函数：构造函数，析构函数，创建节点函数，增删改查操作函数，清空跳表，数据落盘和加载数据及其相关函数，打印跳表函数，返回跳表节点数函数，获得随机层高函数 。

------

#### 2.4.2 构造函数、析构函数、节点构造函数



```c++
template<typename K, typename V> 
SkipList<K, V>::SkipList(int max_level) {
    this->_max_level = max_level;
    this->_skip_list_level = 0;
    this->_element_count = 0;
    K k; V v;
    this->_header = new Node<K, V>(k, v, _max_level);
};

template<typename K, typename V> 
SkipList<K, V>::~SkipList() {

    if (_file_writer.is_open()) {
        _file_writer.close();
    }
    if (_file_reader.is_open()) {
        _file_reader.close();
    }
    delete _header;
}

template<typename K, typename V>
Node<K, V>* SkipList<K, V>::create_node(const K k, const V v, int level) {
    Node<K, V> *n = new Node<K, V>(k, v, level);
    return n;
}
```

------

#### 2.4.3 获得随机层高函数以及返回跳表大小函数



```c++
template<typename K, typename V>
int SkipList<K, V>::get_random_level(){
    int k = 1;
    while (rand() % 2) {
        k++;
    }
    k = (k < _max_level) ? k : _max_level; // 最大不超过上限
    return k;
};
template<typename K, typename V> 
int SkipList<K, V>::size() { 
    return _element_count;  // 会随着节点的添加, 删除, 更新改变
}
```

**注意** :raising_hand: 层高的选择一般根据 **幂次定律** （power law），越大的数出现的概率越小 。

------

#### 2.4.4 put_element()



```c++
template <typename K, typename V>
int SkipList<K, V>::putElement(K key, V value) {
  mtx1.lock();
  Node<K, V> *current = head;
  Node<K, V> *update[maxLevel + 1];
  memset(update, 0, sizeof(Node<K, V> *) * (maxLevel + 1));
  // record frontend node of param key in each level
  for (int i = skipListLevel; i >= 0; i--) {
    while (current->forward[i] != NULL && current->forward[i]->getKey() < key) {
      current = current->forward[i];
    }
    update[i] = current;
  }
  // the first node whose key is ge than param key
  current = current->forward[0];
  // 1. update direcctly, return 1
  if (current != NULL && current->getKey() == key) {
    std::cout << "update key: " << key << ", old value: " << current->getValue()
              << " ,new value: " << value << std::endl;
    current->setValue(value);
    mtx1.unlock();
    return 1;
  }
  // 2. key does not exist, create and insert new node
  int newNodeLevel = getRandomLevel();
  if(newNodeLevel > skipListLevel){
    for(int i = skipListLevel + 1; i <= newNodeLevel; i++){
      update[i] = head;
    }
    skipListLevel = newNodeLevel;
  }
  
  Node<K, V>* newNode = createNode(key, value, newNodeLevel);
  // insert node
  // the operation is similar to insert a node into a list
  // which is like: cur -> next = pre -> next; pre->next = cur; pre = cur; cur = cur->next; 
  // but need to insert from newNode-level to 0-level
  // insert given by key and value into skip list
  /* example:
                            +------------+
                            |  insert 50 |
                            +------------+
  level 4     +-->1+                                                      100
                  |
                  |                       insert +----+
  level 3         1+-------->10+---------------> | 50 |          70       100
                                                 |    |
                                                 |    |
  level 2         1          10         30       | 50 |          70       100
                                                 |    |
                                                 |    |
  level 1         1    4     10         30       | 50 |          70       100
                                                 |    |
                                                 |    |
  level 0         1    4   9 10         30   40  | 50 |  60      70       100
                                                 +----+
  */
  for(int i = newNodeLevel; i >= 0; i--){
    newNode -> forward[i] = update[i] -> forward[i];
    update[i]->forward[i] = newNode;
  }
  elementCount++;
  mtx1.unlock();
  return 0;
}
```

------

#### 2.4.5 delete_element()



```c++
template<typename K, typename V> 
int SkipList<K, V>::delete_element(K key) {
    // 笔者修改了其返回值，如果返回 0 删除成功，返回 -1 删除失败
    // 操作同 insert_element
    mtx.lock();
    Node<K, V> *current = this->_header; 
    Node<K, V> *update[_max_level + 1];
    memset(update, 0, sizeof(Node<K, V>*)*(_max_level + 1));

    for (int i = _skip_list_level; i >= 0; i--) {
        while (current->forward[i] !=NULL && current->forward[i]->get_key() < key) {
            current = current->forward[i];
        }
        update[i] = current;
    }
    current = current->forward[0];
    
    // 1. 非空，且 key 为目标值
    if (current != NULL && current->get_key() == key) {  
        // 从最底层开始删除 update->forward 指向的节点，即目标节点
        for (int i = 0; i <= _skip_list_level; i++) {
            // 如果 update[i] 已经不指向 current 说明 i 的上层也不会指向 current
            // 也说明了被删除节点层高 i - 1。直接退出循环即可
            if (update[i]->forward[i] != current) 
                break;                            
            // 删除操作，等价于 node->next = node->next->next
            update[i]->forward[i] = current->forward[i];
        }
        // 因为可能删除的元素它的层数恰好是当前跳跃表的最大层数
        // 所以此时需要重新确定 _skip_list_level,通过头节点判断
        while (_skip_list_level > 0 && _header->forward[_skip_list_level] == 0) {
            _skip_list_level --; 
        }

        std::cout << "Successfully deleted key : "<< key << std::endl;
        _element_count --;
        mtx.unlock();
    	return 0; // 返回值 0 说明成功删除
    }
    // 2. 笔者添加了没有该键时的情况，打印输出提示
    else {
        std::cout << key << " is not exist, please check your input !\n";
        mtx.unlock();
        return -1; // 返回值 -1 说明没有该键值
    } 
}
```

------

#### 2.4.7 search_element()



```c++
template<typename K, typename V> 
bool SkipList<K, V>::search_element(K key) {
    std::cout << "search_element..." << std::endl;
    Node<K, V> *current = _header;
    // 从最高层开始遍历，找到最底层中最后一个满足小于key的节点
    for (int i = _skip_list_level; i >= 0; i--) {
        while (current->forward[i] && current->forward[i]->get_key() < key) {
            current = current->forward[i];
        }
    }
    current = current->forward[0]; // 该操作后 current->get_key >= key 或者 null
    // 找到
    if (current != NULL && current->get_key() == key) {
        std::cout << "Found key: " << key << ", value: " << current->get_value() << std::endl;
        return true;
    }
	// 没找到
    std::cout << "Not Found Key: " << key << std::endl;
    return false;
}
```

**说明** :sun_with_face: ：代码详细解释见注释。

------

#### 2.4.8 打印跳表



```c++
template<typename K, typename V> 
void SkipList<K, V>::display_list() {
    std::cout << "\n******** Skip List ********"<<"\n"; 
    // 逐层打印
    for (int i = 0; i <= _skip_list_level; i++) {
        Node<K, V> *node = this->_header->forward[i]; 
        std::cout << "Level " << i << ": ";
        while (node != NULL) {
            std::cout << node->get_key() << ":" << node->get_value() << ";";
            node = node->forward[i];
        }
        std::cout << std::endl;
    }
}
```

------

#### 2.4.10 clear()



```c++
template<typename K, typename V> 
void SkipList<K, V>::clear() { 
    std::cout << "clear ..." << std::endl;
    Node<K, V> *node = this->_header->forward[0]; 
    // 删除节点
    while (node != NULL) {
        Node<K, V> *temp = node;
        node = node->forward[0];
        delete temp;
    }
    // 重新初始化 _header
    for (int i = 0; i <= _max_level; i++) {
        this->_header->forward[i] = 0;
    }
    this->_skip_list_level = 0;
    this->_element_count = 0;
}
```

**说明** :sun_with_face: ：代码详细解释见注释。

**注意** :raising_hand_man: ：清空除了头节点以外的节点并且头节点 **forward** 初始化；

------

## 3 项目测试

### 3.1 `skiplist.h` 测试

针对所有提供的 API 进行测试：



```c++
#include <iostream>
#include "skiplist.h"
#define FILE_PATH "./store/dumpFile"

int main() {
    SkipList<std::string, std::string> skipList(6);
    // insert 测试
    std::cout << "--- insert 测试 ---" << std::endl;
	skipList.putElement("1", " one"); 
	skipList.putElement("2", " two"); 
	skipList.putElement("3", " three"); 
	skipList.putElement("abc", " 测试1"); 
    skipList.putElement("中文", " 测试2"); 

    std::cout << "skipList size after insert_element(): " << skipList.size() << std::endl; // 5
 
    // search 测试
    std::cout << "--- search 测试 ---" << std::endl;
    skipList.searchElement("3");
    skipList.searchElement("中文");
    skipList.searchElement("4");

    // delete 测试
    std::cout << "--- delete 测试 ---" << std::endl;
    skipList.deleteElement("3");  // 成功
    skipList.deleteElement("5");  // 失败
    std::cout << "skipList size after delete_element(): " << skipList.size() << std::endl; // 4

    // display 测试
    std::cout << "--- display 测试 ---" << std::endl;
    skipList.displayList();
    
    // clear 测试
    std::cout << "--- clear 测试 ---" << std::endl;
    skipList.clear();
    std::cout << "skipList size after clear(): " << skipList.size() << std::endl; // 0
    return 0;
}
```